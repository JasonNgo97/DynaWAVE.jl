<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · DynaWAVE</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DynaWAVE</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Tutorial</a></li><li><a class="toctext" href="static.html">Static NA</a></li><li class="current"><a class="toctext" href="funs.html">Functions</a><ul class="internal"></ul></li><li><a class="toctext" href="internals.html">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="funs.html">Functions</a></li></ul><a class="edit-page" href="https://github.com/vvjn/DynaWAVE.jl/blob/master/docs/src/funs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynaWAVE.dynawave" href="#DynaWAVE.dynawave"><code>DynaWAVE.dynawave</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dynawave(G1::SparseMatrixCSC,G2::SparseMatrixCSC,
     S::AbstractMatrix, [ beta=0.5,seeds=[] ]);
     skipalign=false,details=false) -&gt; f [, M]</code></pre><p>Given two dynamic networks and node similarities between them, align the two networks by running the DynaWAVE algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>G1</code>,<code>G2</code> : input networks in sparse matrix format</p></li><li><p><code>S</code> : node similarities beween the two networks</p></li><li><p><code>beta</code> : weight between edge and node conservation, <code>beta=1.0</code> weighs   edge conservation highly while <code>beta=0.0</code> weighs node conservation highly</p></li><li><p><code>seeds</code> : seed aligned node pairs. For example, if we know that the   3rd node in the first network is aligned to the 7th node in the   second network, and the 5th node in the first network is aligned to the   9th node in the second network, then we will set <code>seeds = [(3,7), (5,9)]</code></p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>skipalign</code> : Don&#39;t align; just return the alignment details in <a href="internals.html#DynaWAVE.WaveModel"><code>WaveModel</code></a>.</p></li><li><p><code>details</code> : Returns <code>M</code>, the <a href="internals.html#DynaWAVE.WaveModel"><code>WaveModel</code></a>.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>f</code> : Alignment, i.e. node mapping from <code>G1</code> to <code>G2</code>. <code>f[i] describes   node pair</code>nodes1[i], nodes2[f[i]]<code>, where</code>nodes1<code>and</code>nodes2<code>are   the vectors of node names corresponding to</code>G1<code>and</code>G2` respectively.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/DynaWAVE.jl/blob/b047ed05de675be919cb200cd4d2f181e1c74411/src/wave.jl#L200-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynaWAVE.wave" href="#DynaWAVE.wave"><code>DynaWAVE.wave</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">wave(G1::SparseMatrixCSC,G2::SparseMatrixCSC,
     S::AbstractMatrix, [ beta=0.5,seeds=[] ]);
     skipalign=false,details=false) -&gt; f [, M]</code></pre><p>Given two static networks and node similarities between them, align the two networks by running the WAVE algorithm (Yihan Sun, Joseph Crawford, Jie Tang, and Tijana Milenkovic, Simultaneous Optimization of Both Node and Edge Conservation in Network Alignment via WAVE, in Proceedings of the Workshop on Algorithms in Bioinformatics (WABI), Atlanta, GA, USA, September 10-12, 2015, pages 16-39).</p><p><strong>Arguments</strong></p><ul><li><p><code>G1</code>,<code>G2</code> : Input networks in sparse matrix format.</p></li><li><p><code>S</code> : Node similarities beween the two networks.</p></li><li><p><code>beta</code> : Weighs between edge and node conservation, <code>beta=1.0</code> weighs   edge conservation highly while <code>beta=0.0</code> weighs node conservation highly</p></li><li><p><code>seeds</code> : Seed aligned node pairs. For example, if we know that the   3rd node in the first network is aligned to the 7th node in the   second network, and the 5th node in the first network is aligned to the   9th node in the second network, then we will set <code>seeds = [(3,7), (5,9)]</code>.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>skipalign</code> : Don&#39;t align; just return the alignment details in <a href="internals.html#DynaWAVE.WaveModel"><code>WaveModel</code></a>.</p></li><li><p><code>details</code> : Returns <code>M</code>, the <a href="internals.html#DynaWAVE.WaveModel"><code>WaveModel</code></a>.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>f</code> : Alignment, i.e. node mapping from <code>G1</code> to <code>G2</code>. <code>f[i] describes   node pair</code>nodes1[i], nodes2[f[i]]<code>, where</code>nodes1<code>and</code>nodes2<code>are   the vectors of node names corresponding to</code>G1<code>and</code>G2` respectively.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/DynaWAVE.jl/blob/b047ed05de675be919cb200cd4d2f181e1c74411/src/wave.jl#L155-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynaWAVE.shufflealign" href="#DynaWAVE.shufflealign"><code>DynaWAVE.shufflealign</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">shufflealign(method, G1::SparseMatrixCSC,G2::SparseMatrixCSC,
                  S::AbstractMatrix, beta::Float64,
                  seeds=[], details=false) -&gt; f [, M]</code></pre><p>Given two networks and node similarities between them, before aligning using either <a href="funs.html#DynaWAVE.dynawave"><code>dynawave</code></a> or <a href="funs.html#DynaWAVE.wave"><code>wave</code></a>, this shuffles each input network independently before passing the networks to <code>dynawave</code> or <code>wave</code>. This is to remove node order biases when the two networks being aligned have similar node sets with similar node orderings. This is for use in evaluation, where biases like this tend to show much better results that is actually possible with a particular method. We obviously do not want biases like these during evaluation.</p><p>For example, when aligning a network to itself evaluate a network alignment method, the node order of the two networks will be the same and the node set will be the same. This results in the network alignment method &quot;knowing&quot; the true node mapping, and often producing alignments of much higher quality that is actually possible with the method were the true node mapping not known. This method randomizes (shuffles) the node order before handing it to <code>dynawave</code> or <code>wave</code> and then returns the deshuffled alignment.</p><p><strong>Arguments</strong></p><ul><li><p><code>method</code> : If <code>method = dynawave</code>, run the DynaWAVE algorithm after   shuffling the networks. If <code>method = wave</code>, run the WAVE algorithm   after shuffling the networks.</p></li><li><p>See <a href="funs.html#DynaWAVE.dynawave"><code>dynawave</code></a> and <a href="funs.html#DynaWAVE.wave"><code>wave</code></a> for the other arguments.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>f</code> : The resulting alignment has the correct node order with respect to the input <code>G1</code> and <code>G2</code> networks; i.e., it is &quot;deshuffled&quot;.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/DynaWAVE.jl/blob/b047ed05de675be919cb200cd4d2f181e1c74411/src/wave.jl#L241-L272">source</a></section><footer><hr/><a class="previous" href="static.html"><span class="direction">Previous</span><span class="title">Static NA</span></a><a class="next" href="internals.html"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
