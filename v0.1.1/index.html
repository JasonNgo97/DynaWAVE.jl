<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · DynaWAVE</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DynaWAVE</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Tutorial</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#I.-Introduction-1">I. Introduction</a></li><li class="toplevel"><a class="toctext" href="#secm2-1">II. Installation</a></li><li class="toplevel"><a class="toctext" href="#secm3-1">III. Running DynaWAVE with pre-computed node similarities</a></li><li class="toplevel"><a class="toctext" href="#secm4-1">IV. Computing node similarities and then running DynaWAVE</a></li><li class="toplevel"><a class="toctext" href="#secm5-1">V. Mimicking experiments from DynaWAVE paper</a></li><li><a class="toctext" href="#sec4-1">Creating synthetic dynamic networks</a></li><li><a class="toctext" href="#sec5-1">Adding noise to a dynamic network</a></li></ul></li><li><a class="toctext" href="static.html">Static NA</a></li><li><a class="toctext" href="funs.html">Functions</a></li><li><a class="toctext" href="internals.html">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Tutorial</a></li></ul><a class="edit-page" href="https://github.com/vvjn/DynaWAVE.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><h1><a class="nav-anchor" id="I.-Introduction-1" href="#I.-Introduction-1">I. Introduction</a></h1><p>DynaWAVE is our software tool for pairwise global alignment of dynamic networks.</p><p>The following sections contain a tutorial on how to align dynamic networks using DynaWAVE.</p><p>Namely, Section <a href="index.html#secm2-1">II</a> contains installation instructions. Section <a href="index.html#secm3-1">III</a> describes how to align two dynamic networks when pre-computed node similarities are available as input to DynaWAVE. On the other hand, Section <a href="index.html#secm4-1">IV</a> describes how to align two dynamic networks without having available pre-computed node similarities. Section <a href="index.html#secm5-1">V</a> describes how to mimic some of the experiments from our DynaWAVE paper.</p><p>[1] Aligning dynamic networks with DynaWAVE, V. Vijayan and T. Milenković (2017), under revision.</p><h1><a class="nav-anchor" id="secm2-1" href="#secm2-1">II. Installation</a></h1><p><a href="https://julialang.org/">Julia 0.6</a> needs to be installed prior to using DynaWAVE. After starting a command-line terminal (in Linux, Windows, or OS X), DynaWAVE can then be installed by navigating to the base directory of this software and running the single command <code>julia install_dynawave.jl</code>.</p><h1><a class="nav-anchor" id="secm3-1" href="#secm3-1">III. Running DynaWAVE with pre-computed node similarities</a></h1><p>If you have pre-computed node similarities on which you wish to run DynaWAVE, then you may perform the following instructions. If you wish to compute node similarities as in the DynaWAVE paper, then go to Section <a href="index.html#secm4-1">IV</a>.</p><p><strong>1.</strong> Start by navigating to the <code>bin/</code> directory from the base directory of this software, and running the command <code>julia dynawave.jl</code>. This shows examples of how to align two dynamic networks, given node similarities between them. Below are detailed instructions on how to align two example networks.</p><p><strong>2.</strong> Choose two networks to align. DynaWAVE accepts networks in the event list format (see an <a href="ev1.txt">example network 1</a> and an <a href="ev2.txt">example network 2</a>). Each line in the event list format contains an event, which consists of the event&#39;s start time, end time, first node, and second node, respectively.</p><p><strong>3.</strong> Choose a node similarity file. DynaWAVE accepts node similarities in the node pair list format (see an <a href="evsim.txt">example node similarity file</a> corresponding to the above two networks). The node similarity file consists of three columns, the first column being nodes from network 1, the second column being nodes from network 2, and the third column being the node similarities. Each node similarity must be between 0 and 1, inclusive. The node similarity file does not necessarily need to contain similarities between all pairs of nodes across the networks.</p><p><strong>4.</strong> Choose the output alignment file name. DynaWAVE will output the alignment file to this file.</p><p><strong>5.</strong> Given network 1 file, <code>ev1.txt</code>, network 2 file, <code>ev2.txt</code>, node similarity file, <code>evsim.txt</code>, and the output alignment file <code>output_alignment.txt</code>, the following command is run in order to align the two networks:</p><pre><code class="language-none">julia dynawave.jl ev1.txt ev2.txt evsim.txt output_alignment.txt</code></pre><p>The above command will produce the file <code>output_alignment.txt</code>, which contains the alignment. It will also print various statistics related to the alignment.</p><h1><a class="nav-anchor" id="secm4-1" href="#secm4-1">IV. Computing node similarities and then running DynaWAVE</a></h1><p>To follow the instructions below, start <code>julia</code> in the <code>examples/</code> directory from the base directory of this software, and run the following command to load the DynaWAVE library/module:</p><pre><code class="language-julia">using DynaWAVE, NetalignUtils, NetalignMeasures</code></pre><p>If you have pre-computed node similarities on which you wish to run DynaWAVE, then you can use the interface at Section <a href="index.html#secm3-1">III</a>. If you wish to compute the topological node similarities as in the DynaWAVE paper, then perform the instructions in the following <a href="index.html#sec2-1">sub-section</a>. If you wish to compute node similarities from BLAST E-values to align dynamic protein interaction networks, then go to the <a href="index.html#sec3-1">sub-section</a> after that.</p><h3><a class="nav-anchor" id="sec2-1" href="#sec2-1">Computing topological node similarities</a></h3><p>Dynamic GDVs [2], i.e., dynamic graphlet degree vectors, are node descriptors that take both the local structural topology and local temporal topology of nodes in a dynamic network into account. The dynamic GDVs of a network can be calculated using the dynamic graphlet counting code available <a href="https://www3.nd.edu/~cone/DG/">here</a>. In the following example, we will align two networks from the <code>examples/</code> directory, a dynamic yeast network, and the same network with 10% of its events randomized, while using dynamic GDVs as node similarities.</p><p>First, we read the networks and the dynamic GDVs into memory.</p><pre><code class="language-julia">net1 = readeventlist(&quot;yeastlc_original_tw_1_1.dy&quot;)
dgdv1 = readgdv(&quot;yeastlc_original_dgdv_6_4_1.txt&quot;, net1.nodes)
net2 = readeventlist(&quot;yeastlc_rnd_0.10_1_tw_1_1.dy&quot;)
dgdv2 = readgdv(&quot;yeastlc_rnd_0.10_1_dgdv_6_4_1.txt&quot;, net2.nodes)</code></pre><p>Second, we calculate node similarities between node pairs in the two networks using dynamic GDVs, making use of the PCA-based technique described in [2].</p><pre><code class="language-julia">S = NodeSimMeasure(:pcagdvs,dgdv1,dgdv2).S</code></pre><p>(Optionally, you can run <code>writelistmat(&quot;nodesims.txt&quot;, S, net1.nodes, net2.nodes)</code> to save the node similarities to a file, and you can run <code>S = readlistmat(&quot;nodesims.txt&quot;, net1.nodes, net2.nodes)</code>, to read the node similarities from the file.)</p><p>Finally, we align the two networks using DynaWAVE.</p><pre><code class="language-julia">f = dynawave(net1.G, net2.G, S)</code></pre><p><code>f</code> contains the alignment between the two networks. We can construct the node pairs and calculate node correctness as follows</p><pre><code class="language-julia">nodepairs = hcat(net1.nodes, net2.nodes[f])

nc = mean(net1.nodes .== net2.nodes[f])</code></pre><p>We can write the alignment to file as follows.</p><pre><code class="language-julia">writedlm(&quot;yeastlc_aln.txt&quot;, nodepairs)
</code></pre><p>[2] Exploring the structure and function of temporal networks with dynamic graphlets, Y. Hulovatyy,  H. Chen, and  T. Milenković, Bioinformatics, Volume 31, Issue 12, 15 June 2015, Pages i171–i180, (<a href="https://doi.org/10.1093/bioinformatics/btv227">https://doi.org/10.1093/bioinformatics/btv227</a>).</p><h3><a class="nav-anchor" id="sec3-1" href="#sec3-1">Computing external node similarities from BLAST E-values</a></h3><p>Instead of dynamic GDVs, we can alternatively use BLAST E-values to align protein interaction networks as follows.</p><p>First, we read in the E-values to memory. We will be using the same yeast networks as in the above sub-section.</p><pre><code class="language-julia">E = readevalues(&quot;yeastlc_yeastlc_evalues.txt&quot;, net1.nodes, net2.nodes)</code></pre><p>Then, we convert the E-values to node similarities. This is done by converting each E-value to -log(E-value), and then dividing the resulting values with the maximum.</p><pre><code class="language-julia">S = NodeSimMeasure(:evalues, E).S</code></pre><p>Finally, we align the two networks.</p><pre><code class="language-julia">f = dynawave(net1.G, net2.G, S)</code></pre><h1><a class="nav-anchor" id="secm5-1" href="#secm5-1">V. Mimicking experiments from DynaWAVE paper</a></h1><p>If you wish to create synthetic dynamic networks from network models as in the DynaWAVE paper, then go the following <a href="index.html#sec4-1">sub-section</a>. If you wish to add noise to a dynamic network as in the DynaWAVE paper, then go to the <a href="index.html#sec5-1">sub-section</a> after that.</p><h2><a class="nav-anchor" id="sec4-1" href="#sec4-1">Creating synthetic dynamic networks</a></h2><p>In this sub-section, we create random network instances from three network models as in the DynaWAVE paper. Here, we create a random instance of a 1000-node dynamic network using the GEO-GD network model, with parameter <span>$p = 0.3$</span>, and linear node arrival. We let the timespan range from 0 to 30 seconds, initializing the network with a 5-node clique.</p><pre><code class="language-julia">G = rand(GEOGD(0.3, 1, :linear), 1000, 30, 5)</code></pre><p>Here, we create a random instance of a 1000-node dynamic network using the SF-GD network model, with parameters <span>$p = 0.3, q = 0.7$</span>, and exponential node arrival. We let the timespan range from 0 to 30 seconds, initializing the network with a 5-node clique. </p><pre><code class="language-julia">G = rand(SFGD(0.3, 0.7, :exp), 1000, 30, 5)</code></pre><p>Here, we create a random instance of a 1000-node dynamic network using the SNE network model, with parameters <span>$\lambda = 0.032, \alpha = 0.8, \beta = 0.002$</span>, and quadratic node arrival. We let the timespan range from 0 to 30 seconds, initializing the network with a 5-node clique. </p><pre><code class="language-julia">G = rand(SocialNE(0.032, 0.8, 0.002, :quad), 1000, 30, 5)</code></pre><h2><a class="nav-anchor" id="sec5-1" href="#sec5-1">Adding noise to a dynamic network</a></h2><p>In this sub-section, given a dynamic network, we add noise to the network. There are two methods we use in the DynaWAVE paper to add noise to a dynamic network: a strict version (<code>strict_events_shuffle</code>) that only changes the event times in the network (from page 15/30 of [3]), and a non-strict version (<code>links_shuffle</code>) that change both event times and links between nodes in the network (from page 16/39 of [3]).</p><p>Here, we add 30% noise to network <code>G</code> using the strict version.</p><pre><code class="language-julia">net1 = readeventlist(&quot;yeastlc_original_tw_1_1.dy&quot;)
G = net1.G

G30 = strict_events_shuffle(G, 0.30)</code></pre><p>Here, we add 30% noise to network <code>G</code> using the non-strict version.</p><pre><code class="language-julia">net1 = readeventlist(&quot;yeastlc_original_tw_1_1.dy&quot;)
G = net1.G

G30 = links_shuffle(G, 0.30)</code></pre><p>[3] Modern temporal network theory: a colloquium, Petter Holme, European Physical Journal B (2015), (<a href="https://doi.org/10.1140/epjb/e2015-60657-4">https://doi.org/10.1140/epjb/e2015-60657-4</a>).</p><footer><hr/><a class="next" href="static.html"><span class="direction">Next</span><span class="title">Static NA</span></a></footer></article></body></html>
